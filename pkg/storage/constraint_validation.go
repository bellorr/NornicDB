// Package storage - Constraint validation when constraints are created.
package storage

import (
	"fmt"
	"sort"
	"strings"
	"time"
)

// ValidateConstraintOnCreation validates that all existing data satisfies the constraint.
// This is called when CREATE CONSTRAINT is executed, matching Neo4j behavior.
func (b *BadgerEngine) ValidateConstraintOnCreation(c Constraint) error {
	return ValidateConstraintOnCreationForEngine(b, c)
}

// ValidateConstraintOnCreationForEngine validates constraints using the Engine interface.
// This allows callers (like Cypher) to validate through wrapper engines (namespaced, WAL, etc.).
func ValidateConstraintOnCreationForEngine(engine Engine, c Constraint) error {
	switch c.Type {
	case ConstraintUnique:
		return validateUniqueConstraintOnCreationWithEngine(engine, c)
	case ConstraintNodeKey:
		return validateNodeKeyConstraintOnCreationWithEngine(engine, c)
	case ConstraintExists:
		return validateExistenceConstraintOnCreationWithEngine(engine, c)
	case ConstraintTemporal:
		return validateTemporalConstraintOnCreationWithEngine(engine, c)
	default:
		return fmt.Errorf("unknown constraint type: %s", c.Type)
	}
}

// validateUniqueConstraintOnCreation checks all existing nodes for duplicates.
func validateUniqueConstraintOnCreationWithEngine(engine Engine, c Constraint) error {
	if len(c.Properties) != 1 {
		return fmt.Errorf("UNIQUE constraint requires exactly 1 property, got %d", len(c.Properties))
	}

	property := c.Properties[0]
	seen := make(map[interface{}]NodeID)

	// Scan all nodes with this label
	nodes, err := engine.GetNodesByLabel(c.Label)
	if err != nil {
		return fmt.Errorf("scanning nodes: %w", err)
	}

	for _, node := range nodes {
		value := node.Properties[property]
		if value == nil {
			continue // NULL values don't violate uniqueness
		}

		if existingNodeID, found := seen[value]; found {
			return &ConstraintViolationError{
				Type:       ConstraintUnique,
				Label:      c.Label,
				Properties: []string{property},
				Message: fmt.Sprintf("Cannot create UNIQUE constraint: nodes %s and %s both have %s=%v",
					existingNodeID, node.ID, property, value),
			}
		}

		seen[value] = node.ID
	}

	return nil
}

// validateNodeKeyConstraintOnCreation checks all existing nodes for duplicate composite keys.
func validateNodeKeyConstraintOnCreationWithEngine(engine Engine, c Constraint) error {
	if len(c.Properties) < 1 {
		return fmt.Errorf("NODE KEY constraint requires at least 1 property")
	}

	seen := make(map[string]NodeID) // composite key -> nodeID

	nodes, err := engine.GetNodesByLabel(c.Label)
	if err != nil {
		return fmt.Errorf("scanning nodes: %w", err)
	}

	for _, node := range nodes {
		// Extract all property values
		values := make([]interface{}, len(c.Properties))
		hasAllValues := true

		for i, prop := range c.Properties {
			val := node.Properties[prop]
			if val == nil {
				return &ConstraintViolationError{
					Type:       ConstraintNodeKey,
					Label:      c.Label,
					Properties: c.Properties,
					Message: fmt.Sprintf("Cannot create NODE KEY constraint: node %s has null value for property %s",
						node.ID, prop),
				}
			}
			values[i] = val
		}

		if !hasAllValues {
			continue
		}

		// Create composite key string
		compositeKey := fmt.Sprintf("%v", values)

		if existingNodeID, found := seen[compositeKey]; found {
			return &ConstraintViolationError{
				Type:       ConstraintNodeKey,
				Label:      c.Label,
				Properties: c.Properties,
				Message: fmt.Sprintf("Cannot create NODE KEY constraint: nodes %s and %s both have composite key %v=%v",
					existingNodeID, node.ID, c.Properties, values),
			}
		}

		seen[compositeKey] = node.ID
	}

	return nil
}

// validateExistenceConstraintOnCreation checks all existing nodes have the required property.
func validateExistenceConstraintOnCreationWithEngine(engine Engine, c Constraint) error {
	if len(c.Properties) != 1 {
		return fmt.Errorf("EXISTS constraint requires exactly 1 property, got %d", len(c.Properties))
	}

	property := c.Properties[0]

	nodes, err := engine.GetNodesByLabel(c.Label)
	if err != nil {
		return fmt.Errorf("scanning nodes: %w", err)
	}

	for _, node := range nodes {
		value := node.Properties[property]
		if value == nil {
			return &ConstraintViolationError{
				Type:       ConstraintExists,
				Label:      c.Label,
				Properties: []string{property},
				Message: fmt.Sprintf("Cannot create EXISTS constraint: node %s is missing required property %s",
					node.ID, property),
			}
		}
	}

	return nil
}

// validateTemporalConstraintOnCreationWithEngine enforces no-overlap for temporal intervals.
func validateTemporalConstraintOnCreationWithEngine(engine Engine, c Constraint) error {
	if len(c.Properties) != 3 {
		return fmt.Errorf("TEMPORAL constraint requires 3 properties (key, valid_from, valid_to)")
	}

	keyProp := c.Properties[0]
	startProp := c.Properties[1]
	endProp := c.Properties[2]

	nodes, err := engine.GetNodesByLabel(c.Label)
	if err != nil {
		return fmt.Errorf("scanning nodes: %w", err)
	}

	byKey := make(map[string][]temporalInterval)
	for _, node := range nodes {
		keyVal := node.Properties[keyProp]
		if keyVal == nil {
			return &ConstraintViolationError{
				Type:       ConstraintTemporal,
				Label:      c.Label,
				Properties: c.Properties,
				Message:    fmt.Sprintf("Cannot create TEMPORAL constraint: node %s has null %s", node.ID, keyProp),
			}
		}
		key := fmt.Sprint(keyVal)

		start, ok := coerceTemporalTime(node.Properties[startProp])
		if !ok {
			return &ConstraintViolationError{
				Type:       ConstraintTemporal,
				Label:      c.Label,
				Properties: c.Properties,
				Message:    fmt.Sprintf("Cannot create TEMPORAL constraint: node %s has invalid %s", node.ID, startProp),
			}
		}
		end, hasEnd := coerceTemporalTime(node.Properties[endProp])

		interval := temporalInterval{
			start:  start,
			end:    end,
			hasEnd: hasEnd,
			nodeID: node.ID,
		}
		byKey[key] = append(byKey[key], interval)
	}

	for _, intervals := range byKey {
		sort.Slice(intervals, func(i, j int) bool {
			return intervals[i].start.Before(intervals[j].start)
		})
		for i := 1; i < len(intervals); i++ {
			prev := intervals[i-1]
			curr := intervals[i]
			if intervalsOverlap(prev, curr) {
				return &ConstraintViolationError{
					Type:       ConstraintTemporal,
					Label:      c.Label,
					Properties: c.Properties,
					Message: fmt.Sprintf("Cannot create TEMPORAL constraint: overlap between %s and %s",
						prev.nodeID, curr.nodeID),
				}
			}
		}
	}

	return nil
}

// RelationshipConstraint represents a constraint on relationship properties.
type RelationshipConstraint struct {
	Name       string
	Type       ConstraintType
	RelType    string // Relationship type (e.g., "KNOWS", "FOLLOWS")
	Properties []string
}

// ValidateRelationshipConstraint validates relationship property constraints.
func (b *BadgerEngine) ValidateRelationshipConstraint(rc RelationshipConstraint) error {
	switch rc.Type {
	case ConstraintUnique:
		return b.validateUniqueRelationshipConstraint(rc)
	case ConstraintExists:
		return b.validateExistenceRelationshipConstraint(rc)
	default:
		return fmt.Errorf("unsupported relationship constraint type: %s", rc.Type)
	}
}

// validateUniqueRelationshipConstraint checks relationship property uniqueness.
func (b *BadgerEngine) validateUniqueRelationshipConstraint(rc RelationshipConstraint) error {
	if len(rc.Properties) != 1 {
		return fmt.Errorf("UNIQUE constraint on relationships requires exactly 1 property")
	}

	property := rc.Properties[0]
	seen := make(map[interface{}]EdgeID)

	// Scan all relationships of this type
	edges, err := b.AllEdges()
	if err != nil {
		return fmt.Errorf("scanning edges: %w", err)
	}

	for _, edge := range edges {
		if edge.Type != rc.RelType {
			continue
		}

		value := edge.Properties[property]
		if value == nil {
			continue
		}

		if existingEdgeID, found := seen[value]; found {
			return &ConstraintViolationError{
				Type:       ConstraintUnique,
				Label:      rc.RelType,
				Properties: []string{property},
				Message: fmt.Sprintf("Cannot create UNIQUE constraint on relationship: edges %s and %s both have %s=%v",
					existingEdgeID, edge.ID, property, value),
			}
		}

		seen[value] = edge.ID
	}

	return nil
}

// validateExistenceRelationshipConstraint checks required relationship properties.
func (b *BadgerEngine) validateExistenceRelationshipConstraint(rc RelationshipConstraint) error {
	if len(rc.Properties) != 1 {
		return fmt.Errorf("EXISTS constraint on relationships requires exactly 1 property")
	}

	property := rc.Properties[0]

	edges, err := b.AllEdges()
	if err != nil {
		return fmt.Errorf("scanning edges: %w", err)
	}

	for _, edge := range edges {
		if edge.Type != rc.RelType {
			continue
		}

		value := edge.Properties[property]
		if value == nil {
			return &ConstraintViolationError{
				Type:       ConstraintExists,
				Label:      rc.RelType,
				Properties: []string{property},
				Message: fmt.Sprintf("Cannot create EXISTS constraint on relationship: edge %s is missing required property %s",
					edge.ID, property),
			}
		}
	}

	return nil
}

// PropertyTypeConstraint represents a type constraint on properties.
type PropertyTypeConstraint struct {
	Name         string       `json:"name"`
	Label        string       `json:"label"`
	Property     string       `json:"property"`
	ExpectedType PropertyType `json:"expected_type"`
}

// PropertyType represents the expected type of a property.
type PropertyType string

const (
	PropertyTypeString   PropertyType = "STRING"
	PropertyTypeInteger  PropertyType = "INTEGER"
	PropertyTypeFloat    PropertyType = "FLOAT"
	PropertyTypeBoolean  PropertyType = "BOOLEAN"
	PropertyTypeDate     PropertyType = "DATE"
	PropertyTypeDateTime PropertyType = "DATETIME" // Legacy alias for zoned datetime
	// Neo4j temporal property type constraints.
	PropertyTypeZonedDateTime PropertyType = "ZONED DATETIME"
	PropertyTypeLocalDateTime PropertyType = "LOCAL DATETIME"
)

// ValidatePropertyType checks if a value matches the expected type.
// Handles JSON/MessagePack serialization quirks where integers become float64.
func ValidatePropertyType(value interface{}, expectedType PropertyType) error {
	if value == nil {
		return nil // NULL is valid for any type
	}

	switch expectedType {
	case PropertyTypeString:
		if _, ok := value.(string); !ok {
			return fmt.Errorf("expected STRING, got %T", value)
		}
	case PropertyTypeInteger:
		switch v := value.(type) {
		case int, int32, int64:
			return nil
		case float64:
			// JSON/MessagePack deserializes integers as float64
			// Accept if it's a whole number
			if v == float64(int64(v)) {
				return nil
			}
			return fmt.Errorf("expected INTEGER, got %T", value)
		case float32:
			// Also check float32 for whole numbers
			if v == float32(int32(v)) {
				return nil
			}
			return fmt.Errorf("expected INTEGER, got %T", value)
		default:
			return fmt.Errorf("expected INTEGER, got %T", value)
		}
	case PropertyTypeFloat:
		switch value.(type) {
		case float32, float64:
			return nil
		default:
			return fmt.Errorf("expected FLOAT, got %T", value)
		}
	case PropertyTypeBoolean:
		if _, ok := value.(bool); !ok {
			return fmt.Errorf("expected BOOLEAN, got %T", value)
		}
	case PropertyTypeDate:
		switch v := value.(type) {
		case time.Time:
			return nil
		case string:
			if _, err := time.Parse("2006-01-02", strings.TrimSpace(v)); err == nil {
				return nil
			}
			return fmt.Errorf("expected DATE, got %T", value)
		default:
			return fmt.Errorf("expected DATE, got %T", value)
		}
	case PropertyTypeDateTime, PropertyTypeZonedDateTime:
		switch v := value.(type) {
		case time.Time:
			return nil
		case string:
			if isZonedDateTimeString(v) {
				return nil
			}
			return fmt.Errorf("expected ZONED DATETIME, got %T", value)
		default:
			return fmt.Errorf("expected ZONED DATETIME, got %T", value)
		}
	case PropertyTypeLocalDateTime:
		switch v := value.(type) {
		case string:
			if isLocalDateTimeString(v) {
				return nil
			}
			return fmt.Errorf("expected LOCAL DATETIME, got %T", value)
		default:
			return fmt.Errorf("expected LOCAL DATETIME, got %T", value)
		}
	default:
		return fmt.Errorf("unknown property type: %s", expectedType)
	}

	return nil
}

func isZonedDateTimeString(raw string) bool {
	s := strings.TrimSpace(strings.Trim(raw, "'\""))
	for _, layout := range []string{
		time.RFC3339Nano,
		time.RFC3339,
	} {
		if _, err := time.Parse(layout, s); err == nil {
			return true
		}
	}
	return false
}

func isLocalDateTimeString(raw string) bool {
	s := strings.TrimSpace(strings.Trim(raw, "'\""))
	for _, layout := range []string{
		"2006-01-02T15:04:05.999999999",
		"2006-01-02T15:04:05",
		"2006-01-02 15:04:05.999999999",
		"2006-01-02 15:04:05",
	} {
		if _, err := time.Parse(layout, s); err == nil {
			return true
		}
	}
	return false
}

// ValidatePropertyTypeConstraintOnCreation validates existing data against type constraint.
func (b *BadgerEngine) ValidatePropertyTypeConstraintOnCreation(ptc PropertyTypeConstraint) error {
	return ValidatePropertyTypeConstraintOnCreationForEngine(b, ptc)
}

// ValidatePropertyTypeConstraintOnCreationForEngine validates type constraints using Engine.
func ValidatePropertyTypeConstraintOnCreationForEngine(engine Engine, ptc PropertyTypeConstraint) error {
	nodes, err := engine.GetNodesByLabel(ptc.Label)
	if err != nil {
		return fmt.Errorf("scanning nodes: %w", err)
	}

	for _, node := range nodes {
		value := node.Properties[ptc.Property]
		if err := ValidatePropertyType(value, ptc.ExpectedType); err != nil {
			return fmt.Errorf("node %s property %s: %w", node.ID, ptc.Property, err)
		}
	}

	return nil
}
