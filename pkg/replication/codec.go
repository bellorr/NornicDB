package replication

import (
	"bytes"
	"encoding/json"
	"encoding/gob"
	"fmt"
	"time"

	"github.com/orneryd/nornicdb/pkg/storage"
)

// NodePayload is the replication-safe representation of storage.Node, including embeddings.
type NodePayload struct {
	ID               string
	Labels           []string
	Properties       map[string]any
	NamedEmbeddings  map[string][]float32
	ChunkEmbeddings  [][]float32
	CreatedAtUnixNs  int64
	UpdatedAtUnixNs  int64
	DecayScore       float64
	LastAccessedUnix int64
	AccessCount      int64
}

// EdgePayload is the replication-safe representation of storage.Edge.
type EdgePayload struct {
	ID         string
	StartNode  string
	EndNode    string
	Type       string
	Properties map[string]any
	CreatedAt  int64
	Confidence float64
	AutoGenerated bool
}

func init() {
	// Register common concrete types used in Properties to help gob handle interface{} values.
	gob.Register(map[string]any{})
	gob.Register([]any{})
	gob.Register([]string{})
	gob.Register([]float64{})
	gob.Register([]float32{})
	gob.Register([]int{})
	gob.Register([]int64{})
}

func encodeGob(v any) ([]byte, error) {
	var buf bytes.Buffer
	if err := gob.NewEncoder(&buf).Encode(v); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func decodeGob(data []byte, v any) error {
	if err := gob.NewDecoder(bytes.NewReader(data)).Decode(v); err == nil {
		return nil
	}
	// Fallback to JSON for backward compatibility/tests that still marshal JSON.
	return json.Unmarshal(data, v)
}

func encodeNodePayload(node *storage.Node) ([]byte, error) {
	if node == nil {
		return nil, fmt.Errorf("nil node")
	}
	payload := NodePayload{
		ID:              string(node.ID),
		Labels:          node.Labels,
		Properties:      node.Properties,
		NamedEmbeddings: node.NamedEmbeddings,
		ChunkEmbeddings: node.ChunkEmbeddings,
		CreatedAtUnixNs: node.CreatedAt.UnixNano(),
		UpdatedAtUnixNs: node.UpdatedAt.UnixNano(),
		DecayScore:      node.DecayScore,
		LastAccessedUnix: node.LastAccessed.UnixNano(),
		AccessCount:     node.AccessCount,
	}
	return encodeGob(&payload)
}

func decodeNodePayload(data []byte) (*storage.Node, error) {
	var payload NodePayload
	if err := decodeGob(data, &payload); err == nil && payload.ID != "" {
		node := &storage.Node{
			ID:              storage.NodeID(payload.ID),
			Labels:          payload.Labels,
			Properties:      payload.Properties,
			NamedEmbeddings: payload.NamedEmbeddings,
			ChunkEmbeddings: payload.ChunkEmbeddings,
			DecayScore:      payload.DecayScore,
			AccessCount:     payload.AccessCount,
		}
		if payload.CreatedAtUnixNs != 0 {
			node.CreatedAt = time.Unix(0, payload.CreatedAtUnixNs)
		}
		if payload.UpdatedAtUnixNs != 0 {
			node.UpdatedAt = time.Unix(0, payload.UpdatedAtUnixNs)
		}
		if payload.LastAccessedUnix != 0 {
			node.LastAccessed = time.Unix(0, payload.LastAccessedUnix)
		}
		return node, nil
	}
	// Fallback: legacy JSON encoding of storage.Node (no embeddings).
	var legacy storage.Node
	if err := json.Unmarshal(data, &legacy); err != nil {
		return nil, err
	}
	return &legacy, nil
}

func encodeEdgePayload(edge *storage.Edge) ([]byte, error) {
	if edge == nil {
		return nil, fmt.Errorf("nil edge")
	}
	payload := EdgePayload{
		ID:            string(edge.ID),
		StartNode:     string(edge.StartNode),
		EndNode:       string(edge.EndNode),
        Type:          edge.Type,
		Properties:    edge.Properties,
		Confidence:    edge.Confidence,
		AutoGenerated: edge.AutoGenerated,
	}
	if !edge.CreatedAt.IsZero() {
		payload.CreatedAt = edge.CreatedAt.UnixNano()
	}
	return encodeGob(&payload)
}

func decodeEdgePayload(data []byte) (*storage.Edge, error) {
	var payload EdgePayload
	if err := decodeGob(data, &payload); err == nil && payload.ID != "" {
		edge := &storage.Edge{
			ID:            storage.EdgeID(payload.ID),
			StartNode:     storage.NodeID(payload.StartNode),
			EndNode:       storage.NodeID(payload.EndNode),
			Type:          payload.Type,
			Properties:    payload.Properties,
			Confidence:    payload.Confidence,
			AutoGenerated: payload.AutoGenerated,
		}
		if payload.CreatedAt != 0 {
			edge.CreatedAt = time.Unix(0, payload.CreatedAt)
		}
		return edge, nil
	}
	// Fallback legacy JSON encoding of storage.Edge.
	var legacy storage.Edge
	if err := json.Unmarshal(data, &legacy); err != nil {
		return nil, err
	}
	return &legacy, nil
}
