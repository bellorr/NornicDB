package nornicdb

import (
	"context"
	"strings"
	"time"

	"github.com/orneryd/nornicdb/pkg/storage"
)

// onNodeEmbedded is called after the embed worker has successfully generated and
// persisted embeddings for a node. The node ID is expected to be fully-qualified
// (<db>:<id>) because the embed worker operates on the un-namespaced base storage.
//
// This callback keeps the hybrid search indexes in sync and ensures automatic
// relationship inference (Auto-TLP / auto-links) also runs for server-side
// embeddings (i.e., when a node was stored without embeddings initially).
func (db *DB) onNodeEmbedded(node *storage.Node) {
	db.indexNodeFromEvent(node)
	db.runInferenceForEmbeddedNode(node)
}

func (db *DB) runInferenceForEmbeddedNode(node *storage.Node) {
	if db == nil || node == nil {
		return
	}

	hasEmbedding := false
	for _, emb := range node.ChunkEmbeddings {
		if len(emb) > 0 {
			hasEmbedding = true
			break
		}
	}
	if !hasEmbedding {
		return
	}

	dbName, local, ok := splitQualifiedID(string(node.ID))
	if !ok {
		return
	}

	// System DB and reserved internal IDs should never participate in Auto-TLP.
	if dbName == "system" || strings.HasPrefix(local, "qdrant:") {
		return
	}

	inferEngine, _ := db.getOrCreateInferenceService(dbName, nil)
	if inferEngine == nil {
		return
	}

	suggestions, err := inferEngine.OnStoreBestOfChunks(context.Background(), local, node.ChunkEmbeddings)
	if err != nil || len(suggestions) == 0 {
		return
	}

	// Namespaced engine is required because suggestions use local IDs.
	if db.baseStorage == nil {
		return
	}
	storageEngine := storage.NewNamespacedEngine(db.baseStorage, dbName)

	now := time.Now()
	for _, suggestion := range suggestions {
		edge := &storage.Edge{
			ID:            storage.EdgeID(generateID("edge")),
			StartNode:     storage.NodeID(suggestion.SourceID),
			EndNode:       storage.NodeID(suggestion.TargetID),
			Type:          suggestion.Type,
			Confidence:    suggestion.Confidence,
			AutoGenerated: true,
			CreatedAt:     now,
			Properties: map[string]any{
				"reason": suggestion.Reason,
				"method": suggestion.Method,
			},
		}
		_ = storageEngine.CreateEdge(edge) // Best effort
	}
}
